//Portions of this project were developed using suggestions generated by cs50 (OpenAi)

import context from "../scripts/context.js";
import * as Utils from "../scripts/utils.js";
//variabelen
let width = context.canvas.width;
let height = context.canvas.height;
let sizeBgSP = 10;
let stop = false;
//var vr background
let sizeBg = width / 57;
let colors = ["red", "orange", "yellow", "green", "cyan", "blue", "magenta"];
//random number with random begin color,this part pf the code was partially generated with cs50(OpenAI) on 8/11/2024
let startIndex = Math.floor(Math.random() * colors.length);

// array to store square object
let background = [];

//loop that creates an object for each square
for (let i = 0; i < width / sizeBg; i++) {
  let square = {
    x: i * sizeBg,
    y: 0,
    colors: startIndex + i,
  };
  background.push(square);
}

// draws squares bg
function drawSquares() {
  //draws squares = length background array (= screenwidth)
  for (let i = 0; i < background.length; i++) {
    // draws squares = screenheight
    for (let j = 0; j < height / sizeBg; j++) {
      context.fillStyle = colors[(background[i].colors + j) % colors.length];
      context.fillRect(
        background[i].x,
        background[i].y + j * sizeBg,
        sizeBg,
        sizeBg
      );
    }
  }
}

// switch between dev en kg, this part of the code was partially generated with cs50(OpenAI) on 8/11/2024
if (localStorage.getItem("refresh") === "KG") {
  localStorage.setItem("refresh", "DEV");
} else {
  localStorage.setItem("refresh", "KG");
}

//teken kg
function KG(Kposx, y, sizeBg) {
  let Gposx = Kposx + sizeBg * 10;
  context.fillStyle = "white";
  // vert lijnen; k,g
  for (let i = 0; i < 15; i++) {
    context.fillRect(Kposx, y + i * sizeBg, sizeBg, sizeBg);
    context.fillRect(Gposx, y + i * sizeBg, sizeBg, sizeBg);
  }
  // lijn omhoog + lijn omlaag K
  for (let i = 0; i < 8; i++) {
    context.fillRect(
      Kposx + i * sizeBg,
      y + 7 * sizeBg + i * sizeBg,
      sizeBg,
      sizeBg
    );
    context.fillRect(
      Kposx + i * sizeBg,
      y + 7 * sizeBg - i * sizeBg,
      sizeBg,
      sizeBg
    );
  }

  // hroizontale lijnen G + verticale halve van g
  for (let i = 0; i < 7; i++) {
    context.fillRect(Gposx + i * sizeBg, y, sizeBg, sizeBg);
    context.fillRect(Gposx + i * sizeBg, y + sizeBg * 14, sizeBg, sizeBg);
    context.fillRect(
      Gposx + sizeBg * 6,
      y + sizeBg * 14 - i * sizeBg,
      sizeBg,
      sizeBg
    );
  }

  // horizon klein
  context.fillRect(Gposx + sizeBg * 5, y + sizeBg * 8, sizeBg, sizeBg);
}
// teken dev
function DEV(Dposx, y, sizeBg) {
  let Epos = Dposx + sizeBg * 14;
  let Vpos = Epos + sizeBg * 13;
  context.fillStyle = "white";
  // verticalen
  for (let i = 0; i < 15; i++) {
    context.fillRect(Epos, y + i * sizeBg, sizeBg, sizeBg);
    context.fillRect(Dposx, y + i * sizeBg, sizeBg, sizeBg);
  }
  // korte ver D
  for (let i = 0; i < 13; i++) {
    context.fillRect(
      Dposx + 8 * sizeBg,
      y + sizeBg + i * sizeBg,
      sizeBg,
      sizeBg
    );
  }
  //vert V
  for (let x = 0; x < 11; x++) {
    context.fillRect(Vpos, y + x * sizeBg, sizeBg, sizeBg);
    context.fillRect(Vpos + sizeBg * 8, y + x * sizeBg, sizeBg, sizeBg);
  }
  // horizontalen
  for (let i = 0; i < 8; i++) {
    //E
    context.fillRect(Epos + i * sizeBg, y, sizeBg, sizeBg);
    context.fillRect(Epos + i * sizeBg, y + sizeBg * 7, sizeBg, sizeBg);
    context.fillRect(Epos + i * sizeBg, y + sizeBg * 14, sizeBg, sizeBg);
    //D
    context.fillRect(Dposx + i * sizeBg, y, sizeBg, sizeBg);
    context.fillRect(Dposx + i * sizeBg, y + sizeBg * 14, sizeBg, sizeBg);
  }

  // diag
  for (let i = 0; i < 5; i++) {
    context.fillRect(
      Vpos + i * sizeBg,
      y + sizeBg * 10 + i * sizeBg,
      sizeBg,
      sizeBg
    );
    context.fillRect(
      Vpos + 8 * sizeBg - i * sizeBg,
      y + sizeBg * 10 + i * sizeBg,
      sizeBg,
      sizeBg
    );
  }
}

// animate background
update();
function update() {
  context.fillStyle = "white";
  context.fillRect(0, 0, width, height);
  for (let i = 0; i < background.length; i++) {
    background[i].colors++;
  }
  drawSquares();
  signature();
  if (localStorage.getItem("refresh") === "KG") {
    KG(sizeBg * 20, sizeBg * 7, sizeBg);
  } else {
    DEV(sizeBg * 10, sizeBg * 7, sizeBg);
  }
  if (!stop) {
    setTimeout(update, 200);
  }
}

//spaceinvader
function signature() {
  context.fillStyle = Utils.hsla(0, 0, 100, 80);
  //achtergrond
  context.fillRect(
    width - sizeBgSP * 10,
    height - sizeBgSP * 8 + 2.5,
    sizeBgSP * 7,
    sizeBgSP * 7
  );
  context.fillStyle = "#C17AD0";
  //rij 1
  context.fillRect(
    width - sizeBgSP * 8,
    height - sizeBgSP * 7 + 2.5,
    sizeBgSP,
    sizeBgSP
  );
  context.fillRect(
    width - sizeBgSP * 6,
    height - sizeBgSP * 7 + 2.5,
    sizeBgSP,
    sizeBgSP
  );
  //rechter balk
  context.fillRect(
    width - sizeBgSP * 5,
    height - sizeBgSP * 6 + 2.5,
    sizeBgSP,
    sizeBgSP * 4
  );
  //linkerbalk
  context.fillRect(
    width - sizeBgSP * 9,
    height - sizeBgSP * 6 + 2.5,
    sizeBgSP,
    sizeBgSP * 4
  );
  //midden rechts
  context.fillRect(
    width - sizeBgSP * 6,
    height - sizeBgSP * 5 + 2.5,
    sizeBgSP,
    sizeBgSP
  );
  //midden links
  context.fillRect(
    width - sizeBgSP * 8,
    height - sizeBgSP * 5 + 2.5,
    sizeBgSP,
    sizeBgSP
  );
  ///midden
  context.fillRect(
    width - sizeBgSP * 7,
    height - sizeBgSP * 4 + 2.5,
    sizeBgSP,
    sizeBgSP
  );
}

//interactie bg stop
window.onkeydown = stopBg;
window.onmousedown = stopBg;
/**
 *
 * @param {KeyboardEvent*} e
 */
function stopBg(e) {
  if (e.keyCode == 0 || e.keyCode == 32) {
    stop = true;
  } else {
    stop = false;
    setTimeout(update, 200);
  }
}
